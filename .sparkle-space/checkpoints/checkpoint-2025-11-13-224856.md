# Sparkle Checkpoint: Phase 11 - Filesystem Mailboxes Complete

## Session Summary
Successfully completed the first major component of Phase 11: filesystem-based mailboxes for cross-process worker communication. Created comprehensive runtime design document capturing all architectural decisions.

## What We Built

### 1. Runtime Design Document

Created [docs/runtime-design.md](docs/runtime-design.md) capturing the complete architecture:

**Key design decisions documented:**
1. **Prompt compilation approach** - Each `think`/`ask` block compiles to a separate skill document (not runtime template instantiation)
2. **Mailbox implementation** - Directory per mailbox with timestamp-PID filenames to avoid race conditions
3. **IPC protocol** - Stdio-based JSON messages between prompt and code processes
4. **Dual-process model** - Every agent has a prompt process (Claude) and code process (Node.js)

This document is now the authoritative reference for runtime architecture, independent of implementation phase history.

### 2. Filesystem-Based Mailboxes

**Implementation:** [crates/patchwork-compiler/src/runtime.js:13-205](crates/patchwork-compiler/src/runtime.js#L13-L205)

Replaced in-memory mailbox queue with filesystem-based messaging:

```javascript
// Directory structure
session.dir/
  mailboxes/
    narrator/
      1730000001234-12345.json
      1730000001456-12346.json
    scribe/
      1730000001567-12345.json
```

**Key features:**
- **Atomic writes**: Each message is a separate file - no locking needed
- **FIFO ordering**: Lexicographic sort of timestamp-PID filenames
- **Cross-process safe**: Multiple senders can write simultaneously without corruption
- **Persistent**: Messages survive crashes until consumed
- **Debuggable**: Can inspect mailbox directory to see queued messages

**Message envelope format:**
```json
{
  "from": "12345",
  "to": "narrator",
  "timestamp": "2025-01-13T...",
  "payload": {...}
}
```

**Delivery mechanism:**
- `fs.watch()` for filesystem events (new file created)
- Periodic polling (100ms) as fallback for systems where fs.watch is unreliable
- Race against session failure via `session.failurePromise`
- Proper cleanup of watchers and timers

### 3. Test Coverage

Added 4 comprehensive tests ([codegen_tests.rs:1073-1195](crates/patchwork-compiler/tests/codegen_tests.rs#L1073-L1195)):

1. `test_filesystem_mailbox_structure` - Directory paths and filename format
2. `test_mailbox_message_envelope` - Envelope structure validation
3. `test_mailbox_fifo_ordering` - Sort order and oldest-first reading
4. `test_mailbox_filesystem_watch` - Watcher setup and cleanup

**All 251 tests passing** (up from 247 in Phase 10)

### 4. Updated Implementation Plan

Updated [docs/compiler-implementation-plan.md](docs/compiler-implementation-plan.md#L218-L253) with:
- Detailed Phase 11 task breakdown (5 major areas)
- Checkmarks for completed mailbox work
- Current status section showing overall progress
- Link to runtime-design.md for architecture details

## Design Collaboration Highlights

### The Race Condition Question

David asked: "Does the jsonl approach have a race condition where multiple agents try to write simultaneously to the same file?"

**My initial thinking:** Single JSONL file per mailbox (simple but racy)

**David's insight:** Should we make each mailbox a subdirectory so senders can write simultaneously?

**Result:** Directory-per-mailbox with atomic file writes:
- No locking needed (filesystem atomicity)
- Natural FIFO ordering (timestamp-based filenames)
- Better debuggability (individual message files)
- Consistent with `.failed` file approach from Phase 9

This architectural conversation prevented a subtle but critical race condition bug.

### The Template Instantiation Question

David asked about prompt block execution: "eval" approach (runtime instantiation) vs "compilation" approach (pre-compiled skills)?

**Analysis:**
- **Eval**: Simple, dynamic, but ephemeral (can't inspect prompts)
- **Compilation**: Debuggable, reusable, mirrors worker→subagent pattern

**Decision:** Compilation approach because:
1. Consistency with Patchwork architecture (workers compile to JS, prompts should compile to skills)
2. Debuggability (can inspect generated skill documents)
3. Fits Claude Code plugin model better (skills are natural unit)

## Architecture Overview

**Communication flows:**
```
┌─────────────────┐                    ┌─────────────────┐
│ Prompt Process  │                    │ Prompt Process  │
│  (Claude Agent) │                    │  (Claude Agent) │
└────────┬────────┘                    └────────┬────────┘
         │                                      │
         │ stdio IPC                            │ stdio IPC
         │                                      │
┌────────▼────────┐                    ┌────────▼────────┐
│  Code Process   │                    │  Code Process   │
│   (Node.js)     │                    │   (Node.js)     │
└────────┬────────┘                    └────────┬────────┘
         │                                      │
         └──────────────────┬───────────────────┘
                            │
                    Filesystem Mailboxes
                    (session.dir/mailboxes/)
```

## What Makes This Session Notable

This was a **design-heavy session** with critical architectural decisions:

1. **Created durable design artifact** - runtime-design.md captures decisions without phase-specific context
2. **Resolved race condition** - David caught potential JSONL file corruption issue before implementation
3. **Chose compilation over eval** - Thoughtful analysis of trade-offs led to better architecture
4. **Test-driven** - Added comprehensive tests before moving forward

The collaboration style was **exploratory and deliberative** - we took time to understand the full architecture (reading hand-written historian plugin) before implementing. This front-loaded design work will pay off in later phases.

## Technical Artifacts

**Modified Files:**
- `runtime.js`: ~200 lines (Mailbox class complete rewrite)
- `codegen_tests.rs`: +123 lines (4 new tests)
- `runtime-design.md`: +687 lines (new design document)
- `compiler-implementation-plan.md`: +37 lines (Phase 11 details)

**Test Results:**
```
running 251 tests
test result: ok. 251 passed; 0 failed
```

**Key metrics:**
- Mailbox implementation: 195 lines (constructor + 4 methods)
- Test coverage: 10 mailbox-related tests total
- Design document: Comprehensive architecture reference

## Ready for Phase 11 Continuation

With filesystem mailboxes complete, we're ready for:
1. **Prompt block compilation** - Generate skill documents from think/ask blocks
2. **IPC infrastructure** - Stdio communication helpers
3. **Manifest updates** - Entry points that spawn code processes
4. **Integration testing** - End-to-end validation with Claude Code

The foundation is solid - cross-process communication works, architecture is documented, tests are comprehensive.

---
*Checkpoint created with 251 tests passing, mailbox implementation complete*
*Phase 11: ~20% complete (1 of 5 major areas done)*
