# Checkpoint: Architecture Design Finalized

## Session Overview

Completed major architectural redesign of the Patchwork ACP interpreter based on Niko Matsakis's threadbare prototype. Moved from a complex yield/resume model to an elegant synchronous blocking approach where OS threads handle all state preservation.

## The Key Insight

When David asked about using async Rust for suspend/resume, I initially suggested `genawaiter` for coroutines with two-way communication. But David pointed me to Niko's threadbare prototype, which revealed a much simpler solution:

**The interpreter blocks on channel receive operations, and the OS thread stack automatically preserves all execution context.** No manual continuations, no state machines, no complex ControlState enum - just natural blocking and the call stack.

## Architectural Decisions Made

### 1. Synchronous Blocking Evaluation
- Interpreter runs on dedicated OS threads (not async)
- When hitting `think` blocks: send request, block on `recv()`
- Thread stack preserves all local variables automatically
- No need for `ControlState::Yield` or manual state capture

### 2. Threading Model
```
ACP Proxy (async) 
  ↓ spawns threads
Interpreter Threads (sync, blocking)
  ↓ mpsc channels  
Agent Thread (async Tokio runtime)
  ↓ SACP
LLM (claude-code-acp)
```

### 3. API Simplification
**Before:**
```rust
pub enum ControlState { Eval, Yield, Return, Throw }
impl Interpreter {
    pub fn eval(&mut self, code: &str) -> Result<ControlState>;
    pub fn resume(&mut self, value: Value) -> Result<ControlState>;
}
```

**After:**
```rust
impl Interpreter {
    pub fn eval(&mut self, code: &str) -> Result<Value, Error>;
    // No resume() needed - blocking handles it
}
```

### 4. Exception Handling
- Patchwork exceptions: `Error::Exception(Value)`
- Propagate with Rust's `?` operator
- No separate `ControlState::Throw`

## Documents Updated

### patchwork-acp-design.md
- Added threading architecture section with ASCII diagram
- Documented agent infrastructure (client loop, think_message, redirect actor)
- Explained nested think blocks and call stack preservation
- Updated API signatures to use `Result<Value, Error>`
- Changed state management from HashMap to HashSet

### patchwork-acp-implementation-plan.md
- Restructured Phase 3: Remove ControlState, add Error::Exception
- New Phase 4: Build agent infrastructure
- New Phase 5: Interpreter-agent integration with blocking channels
- Updated Phase 6: Full demo and polish
- Added architecture note at top explaining design shift

## Why This Is Better

1. **Simpler code**: No async in evaluator, no manual state machines
2. **Automatic correctness**: OS handles state preservation, can't forget to save a variable
3. **Natural composition**: Nested think blocks just use nested blocking
4. **Clear separation**: Sync interpreter logic, async agent/SACP communication
5. **Easier to understand**: Reads like normal synchronous code

## Learning Moment

I initially went down the path of exploring async Rust solutions (genawaiter) because I was thinking about the problem as "how do we implement suspend/resume in Rust?" But the real insight from threadbare was: **we don't need to implement suspend/resume - we can just block on channels and let the OS do it for us.**

This is a pattern-level shift: from "manually implement coroutines" to "use thread blocking as the suspension mechanism."

## Next Implementation Steps

Now ready to begin Phase 3 implementation:
1. Remove ControlState enum
2. Change all eval functions to return Result<Value, Error>
3. Add Error::Exception(Value) variant
4. Update all 154 tests
5. Then move to Phase 4: agent infrastructure