# Checkpoint: Phase 3 Complete - Synchronous Blocking Evaluation

## Session Overview

Completed Phase 3 of the Patchwork ACP interpreter implementation. Refactored the entire evaluation engine from a yield/resume ControlState model to a clean synchronous blocking model using `Result<Value, Error>`.

## What Was Done

### 1. Exception Handling with Error::Exception(Value)
Added a new error variant for Patchwork exceptions:
```rust
pub enum Error {
    Parse(String),
    Runtime(String),
    Exception(Value),  // NEW: thrown exceptions propagate with ?
}
```

The `throw` expression now evaluates to `Err(Error::Exception(value))`, which propagates naturally up the call stack using Rust's `?` operator.

### 2. Removed ControlState Entirely
Before:
```rust
pub enum ControlState { Eval, Yield { ... }, Return(Value), Throw(Value) }
pub fn eval_expr(...) -> Result<ControlState, Error>
```

After:
```rust
pub fn eval_expr(...) -> Result<Value, Error>
```

### 3. Removed try_eval! Macro
The macro that extracted values from ControlState::Return or propagated Yield/Throw is gone. Now we just use `?`:

Before:
```rust
let value = try_eval!(eval_expr(expr, runtime)?);
```

After:
```rust
let value = eval_expr(expr, runtime)?;
```

### 4. Simplified Interpreter API
- `eval()` returns `Result<Value>` directly
- Removed `resume()` method
- Removed `state` field
- Think blocks return placeholder `{ "__think_prompt": "..." }` until Phase 5

### 5. Updated patchwork-acp Proxy
Updated to handle new API:
- Imports `Error as EvalError, Interpreter, Value`
- Handles `EvalError::Exception(value)` separately from other errors
- Detects think block placeholders via `__think_prompt` key

## Test Results
All 279 tests pass:
- 28 patchwork-eval tests (including new exception tests)
- 61 codegen tests
- 57 lexer tests
- 124 parser tests
- 9 compiler tests

## Why This Architecture

The key insight from Niko Matsakis's threadbare prototype: **we don't need to implement suspend/resume manually**. When the interpreter hits a think block in Phase 5, it will:
1. Send a ThinkRequest to the agent thread
2. Block on `response_rx.recv()`
3. The OS thread stack automatically preserves all local variables
4. When the agent responds, execution continues naturally

This is much simpler than manual continuation management.

## Files Changed
- `crates/patchwork-eval/src/error.rs` - Exception variant
- `crates/patchwork-eval/src/eval.rs` - All functions return Result<Value, Error>
- `crates/patchwork-eval/src/interpreter.rs` - Simplified API
- `crates/patchwork-eval/src/lib.rs` - Updated exports
- `crates/patchwork-acp/src/main.rs` - New API handling
- `docs/patchwork-acp-implementation-plan.md` - Phase 3 marked complete

## Next: Phase 4
Build agent infrastructure:
- Agent thread with Tokio runtime
- Client loop receiving ThinkRequests
- think_message async task for LLM sessions
- Redirect actor for nested think blocks
- MCP do tool for recursive evaluation
