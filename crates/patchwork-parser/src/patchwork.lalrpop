// Patchwork grammar - Milestone 2: Top-level items and block structure

use crate::token::ParserToken;
use crate::adapter::ParseError;
use crate::ast::*;

grammar<'input>(input: &'input str);

// External token definition - we use our custom lexer
extern {
    type Location = usize;
    type Error = ParseError;

    enum ParserToken<'input> {
        // Whitespace
        whitespace => ParserToken::Whitespace(<&'input str>),
        newline => ParserToken::Newline(<&'input str>),

        // String literals
        string_start => ParserToken::StringStart,
        string_end => ParserToken::StringEnd,
        string_text => ParserToken::StringText(<&'input str>),
        single_quote_string => ParserToken::SingleQuoteString(<&'input str>),
        dollar => ParserToken::Dollar,

        // Prompt operators
        "think" => ParserToken::Think,
        "ask" => ParserToken::Ask,
        "do" => ParserToken::Do,

        // Keywords
        "import" => ParserToken::Import,
        "from" => ParserToken::From,
        "var" => ParserToken::Var,
        "if" => ParserToken::If,
        "else" => ParserToken::Else,
        "for" => ParserToken::For,
        "while" => ParserToken::While,
        "await" => ParserToken::Await,
        "task" => ParserToken::Task,
        "skill" => ParserToken::Skill,
        "fun" => ParserToken::Fun,
        "type" => ParserToken::Type,
        "return" => ParserToken::Return,
        "succeed" => ParserToken::Succeed,
        "fail" => ParserToken::Fail,
        "break" => ParserToken::Break,
        "self" => ParserToken::SelfKw,
        "in" => ParserToken::In,

        // Literals
        "true" => ParserToken::True,
        "false" => ParserToken::False,
        number => ParserToken::Number(<&'input str>),
        identifier => ParserToken::Identifier(<&'input str>),

        // Multi-character operators
        "..." => ParserToken::Ellipsis,
        "->" => ParserToken::Arrow,
        "==" => ParserToken::Eq,
        "!=" => ParserToken::Neq,
        "<=" => ParserToken::Lte,
        ">=" => ParserToken::Gte,
        "&&" => ParserToken::AndAnd,
        "||" => ParserToken::OrOr,

        // Punctuation
        "{" => ParserToken::LBrace,
        "}" => ParserToken::RBrace,
        "(" => ParserToken::LParen,
        ")" => ParserToken::RParen,
        "[" => ParserToken::LBracket,
        "]" => ParserToken::RBracket,
        ";" => ParserToken::Semicolon,
        "," => ParserToken::Comma,
        ":" => ParserToken::Colon,
        "@" => ParserToken::At,

        // Single-character operators
        "<" => ParserToken::Lt,
        ">" => ParserToken::Gt,
        "+" => ParserToken::Plus,
        "-" => ParserToken::Minus,
        "*" => ParserToken::Star,
        "/" => ParserToken::Slash,
        "%" => ParserToken::Percent,
        "!" => ParserToken::Bang,
        "=" => ParserToken::Assign,
        "|" => ParserToken::Pipe,
        "&" => ParserToken::Ampersand,
        "." => ParserToken::Dot,

        // Prompt text
        prompt_text => ParserToken::PromptText(<&'input str>),

        // Comments
        comment => ParserToken::Comment(<&'input str>),

        // Special
        end => ParserToken::End,
    }
}

// ====================
// Grammar Rules
// ====================

// Program: top-level items (with optional newlines between them - similar to StatementList)
pub Program: Program<'input> = {
    newline* <head:Item> <tail:(newline+ <Item>)*> newline* end => {
        let mut items = vec![head];
        items.extend(tail);  // lalrpop flattens (newline+ <Item>) to just Item
        Program { items }
    },
    newline* end => Program { items: vec![] },  // Empty program
};

// Top-level item
Item: Item<'input> = {
    <ImportDecl> => Item::Import(<>),
    <SkillDecl> => Item::Skill(<>),
    <TaskDecl> => Item::Task(<>),
    <FunctionDecl> => Item::Function(<>),
};

// Import declaration: `import path` or `import ./{a, b, c}`
ImportDecl: ImportDecl<'input> = {
    "import" <path:ImportPath> => ImportDecl { path },
};

// Import path
ImportPath: ImportPath<'input> = {
    // Relative multi-import: ./{analyst, narrator, scribe}
    "." "/" "{" <head:identifier> <tail:("," <identifier>)*> "}" => {
        let mut names = vec![head];
        names.extend(tail);
        ImportPath::RelativeMulti(names)
    },
    // Simple dotted path: For now, just accept identifier sequences
    // Will expand this in later milestones if needed
    <id:identifier> => ImportPath::Simple(vec![id]),
};

// Skill declaration: skill name(params) { body }
SkillDecl: SkillDecl<'input> = {
    "skill" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        SkillDecl { name, params, body }
    },
};

// Task declaration: task name(params) { body }
TaskDecl: TaskDecl<'input> = {
    "task" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        TaskDecl { name, params, body }
    },
};

// Function declaration: fun name(params) { body }
FunctionDecl: FunctionDecl<'input> = {
    "fun" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        FunctionDecl { name, params, body }
    },
};

// Parameter list (comma-separated identifiers)
ParamList: Vec<Param<'input>> = {
    // Empty list
    => vec![],
    // Single param
    <head:identifier> => vec![Param { name: head }],
    // Multiple params
    <head:identifier> <tail:("," <identifier>)+> => {
        let mut params = vec![Param { name: head }];
        for name in tail {
            params.push(Param { name });
        }
        params
    },
};

// Block: { statements }
// Statements are separated by newlines or semicolons (Swift-style)
Block: Block<'input> = {
    "{" <statements:StatementList> "}" => Block { statements },
};

// Separator: newline or semicolon (at least one required between statements)
Separator: () = {
    newline => (),
    ";" => (),
};

// Statement list
// Key insight from Swift: newlines (or semicolons) SEPARATE statements.
// This means after "return", if there's a newline, we know return has no value.
// If there's no newline, the expression continues on the same logical line.
StatementList: Vec<Statement<'input>> = {
    // Empty block (allow leading/trailing newlines)
    newline* => vec![],

    // Non-empty: optional leading newlines, then statements separated by newlines/semicolons
    newline* <head:Statement> <tail:(Separator+ <Statement>)*> Separator* => {
        let mut result = vec![head];
        result.extend(tail);
        result
    },
};

// Statement (Milestone 3: simple statements)
// Order matters for ambiguity resolution - more specific rules first
Statement: Statement<'input> = {
    // Control flow with blocks - unambiguous (blocks provide boundaries)
    <IfStmt>,
    <ForStmt>,
    <WhileStmt>,

    // Variable declarations - handled explicitly with all variants
    <VarDeclStmt>,

    // Keywords that can't start expressions - unambiguous
    <ReturnStmt>,
    <SucceedStmt>,
    <FailStmt>,
    <BreakStmt>,

    // Expression statement last (catch-all)
    <ExprStmt>,
};

// Variable declaration
// Reordered to try with = first (greedy matching for init)
VarDeclStmt: Statement<'input> = {
    // var x: type = expr (most specific - try first)
    "var" <name:identifier> ":" <type_ann:TypeExpr> "=" <init:Expr> => {
        Statement::VarDecl { name, type_ann: Some(type_ann), init: Some(init) }
    },
    // var x = expr (no type annotation)
    "var" <name:identifier> "=" <init:Expr> => {
        Statement::VarDecl { name, type_ann: None, init: Some(init) }
    },
    // var x: type (no init) - only matches if no = follows
    "var" <name:identifier> ":" <type_ann:TypeExpr> => {
        Statement::VarDecl { name, type_ann: Some(type_ann), init: None }
    },
    // var x (no init, no type)
    "var" <name:identifier> => {
        Statement::VarDecl { name, type_ann: None, init: None }
    },
};

// If statement (block provides clear termination)
IfStmt: Statement<'input> = {
    "if" <condition:Expr> <then_block:Block> <else_block:("else" <Block>)?> => {
        Statement::If { condition, then_block, else_block }
    },
};

// For loop (block provides clear termination)
ForStmt: Statement<'input> = {
    "for" "var" <var:identifier> "in" <iter:Expr> <body:Block> => {
        Statement::For { var, iter, body }
    },
};

// While loop (block provides clear termination)
WhileStmt: Statement<'input> = {
    "while" "(" <condition:Expr> ")" <body:Block> => {
        Statement::While { condition, body }
    },
};

// Return statement
// To resolve the ambiguity, we need to be explicit about when there's no expression.
// The parser sees "return" and doesn't know if what follows is:
// 1) part of an expression for this return
// 2) the start of the next statement
//
// Solution: Accept that statements in blocks don't need explicit terminators
// because blocks themselves provide boundaries. But we need to restrict what
// can be a statement-level expression vs a return expression.
//
// Simpler: just always try to parse an expression if possible (greedy matching)
// This rule says: ALWAYS try to match "return <Expr>" first due to ordering
ReturnStmt: Statement<'input> = {
    "return" <e:Expr?> => Statement::Return(e),
};

// Succeed/Fail/Break - these are unambiguous keywords
SucceedStmt: Statement<'input> = {
    "succeed" => Statement::Succeed,
};

FailStmt: Statement<'input> = {
    "fail" => Statement::Fail,
};

BreakStmt: Statement<'input> = {
    "break" => Statement::Break,
};

// Expression statement
ExprStmt: Statement<'input> = {
    <Expr> => Statement::Expr(<>),
};

// Type expression (Milestone 3: simple names only)
TypeExpr: TypeExpr<'input> = {
    <identifier> => TypeExpr::Name(<>),
};

// Expression with precedence (Milestone 4)
// Manual precedence climbing approach for clarity
Expr: Expr<'input> = { AssignExpr };

// Assignment (right-associative)
AssignExpr: Expr<'input> = {
    <left:PipeExpr> "=" <right:AssignExpr> => Expr::Binary {
        op: BinOp::Assign,
        left: Box::new(left),
        right: Box::new(right),
    },
    PipeExpr,
};

// Pipe operator
PipeExpr: Expr<'input> = {
    <left:PipeExpr> "|" <right:OrExpr> => Expr::Binary {
        op: BinOp::Pipe,
        left: Box::new(left),
        right: Box::new(right),
    },
    OrExpr,
};

// Logical OR
OrExpr: Expr<'input> = {
    <left:OrExpr> "||" <right:AndExpr> => Expr::Binary {
        op: BinOp::Or,
        left: Box::new(left),
        right: Box::new(right),
    },
    AndExpr,
};

// Logical AND
AndExpr: Expr<'input> = {
    <left:AndExpr> "&&" <right:CompExpr> => Expr::Binary {
        op: BinOp::And,
        left: Box::new(left),
        right: Box::new(right),
    },
    CompExpr,
};

// Comparison operators
CompExpr: Expr<'input> = {
    <left:CompExpr> "==" <right:RangeExpr> => Expr::Binary {
        op: BinOp::Eq,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:CompExpr> "!=" <right:RangeExpr> => Expr::Binary {
        op: BinOp::NotEq,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:CompExpr> "<" <right:RangeExpr> => Expr::Binary {
        op: BinOp::Lt,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:CompExpr> ">" <right:RangeExpr> => Expr::Binary {
        op: BinOp::Gt,
        left: Box::new(left),
        right: Box::new(right),
    },
    RangeExpr,
};

// Range operator
RangeExpr: Expr<'input> = {
    <left:RangeExpr> "..." <right:AddExpr> => Expr::Binary {
        op: BinOp::Range,
        left: Box::new(left),
        right: Box::new(right),
    },
    AddExpr,
};

// Addition/Subtraction
AddExpr: Expr<'input> = {
    <left:AddExpr> "+" <right:MulExpr> => Expr::Binary {
        op: BinOp::Add,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:AddExpr> "-" <right:MulExpr> => Expr::Binary {
        op: BinOp::Sub,
        left: Box::new(left),
        right: Box::new(right),
    },
    MulExpr,
};

// Multiplication/Division
MulExpr: Expr<'input> = {
    <left:MulExpr> "*" <right:UnaryExpr> => Expr::Binary {
        op: BinOp::Mul,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:MulExpr> "/" <right:UnaryExpr> => Expr::Binary {
        op: BinOp::Div,
        left: Box::new(left),
        right: Box::new(right),
    },
    UnaryExpr,
};

// Unary operators
UnaryExpr: Expr<'input> = {
    "!" <operand:UnaryExpr> => Expr::Unary {
        op: UnOp::Not,
        operand: Box::new(operand),
    },
    "-" <operand:UnaryExpr> => Expr::Unary {
        op: UnOp::Neg,
        operand: Box::new(operand),
    },
    PostfixExpr,
};

// Postfix expressions: member access, call, index
// These are left-associative and have the same precedence
PostfixExpr: Expr<'input> = {
    // Member access: obj.field
    <object:PostfixExpr> "." <field:identifier> => Expr::Member {
        object: Box::new(object),
        field,
    },

    // Function call: func(a, b, c)
    <callee:PostfixExpr> "(" <args:ExprList> ")" => Expr::Call {
        callee: Box::new(callee),
        args,
    },

    // Index access: arr[i]
    <object:PostfixExpr> "[" <index:Expr> "]" => Expr::Index {
        object: Box::new(object),
        index: Box::new(index),
    },

    // Primary expressions
    <PrimaryExpr>,
};

// Primary expressions (atoms)
PrimaryExpr: Expr<'input> = {
    // Literals
    <identifier> => Expr::Identifier(<>),
    <number> => Expr::Number(<>),
    <StringLiteral> => Expr::String(<>),
    "true" => Expr::True,
    "false" => Expr::False,
    "self" => Expr::Identifier("self"),

    // Prompt expressions (think and ask can be used as expressions)
    <ThinkExpr>,
    <AskExpr>,
    // Note: do { } is NOT a standalone expression - only used inside think/ask blocks

    // Parenthesized expression
    "(" <e:Expr> ")" => Expr::Paren(Box::new(e)),
};

// String literal with interpolation support
// Parses: "text", "$id", "${expr}", "$(cmd)", or combinations
StringLiteral: StringLiteral<'input> = {
    string_start <parts:StringPart*> string_end => StringLiteral { parts },
};

// A single part of a string - either text or interpolation
StringPart: StringPart<'input> = {
    // Plain text
    <text:string_text> => StringPart::Text(text),

    // Interpolation: $id form
    dollar <id:identifier> => StringPart::Interpolation(Box::new(Expr::Identifier(id))),

    // Interpolation: ${expr} form
    dollar "{" <e:Expr> "}" => StringPart::Interpolation(Box::new(e)),

    // Interpolation: $(cmd) form - parses as expression
    dollar "(" <e:Expr> ")" => StringPart::Interpolation(Box::new(e)),
};

// Expression list (for function arguments)
ExprList: Vec<Expr<'input>> = {
    // Empty list
    => vec![],
    // Single expr
    <head:Expr> => vec![head],
    // Multiple exprs
    <head:Expr> <tail:("," <Expr>)+> => {
        let mut exprs = vec![head];
        exprs.extend(tail);
        exprs
    },
};

// ===== Prompt Expressions (Milestone 5) =====

// Think expression: think { ... }
// Note: think { } || ask { } is just a binary || expression, not special syntax
ThinkExpr: Expr<'input> = {
    "think" "{" <content:PromptBlock> "}" => Expr::Think(content),
};

// Ask expression: ask { ... }
AskExpr: Expr<'input> = {
    "ask" "{" <content:PromptBlock> "}" => Expr::Ask(content),
};

// Do expression: do { ... }
// Note: Lexer emits Do token only inside prompt blocks
// Outside prompts, "do" is just an identifier
// We'll handle both cases by also checking for identifier "do"
DoExpr: Expr<'input> = {
    // Inside prompt context - lexer emits Do token
    "do" "{" <statements:StatementList> "}" => Expr::Do(Block { statements }),
};

// Prompt block - mixture of text and embedded do blocks
// Note: Lexer produces multiple prompt_text tokens (one per word) plus newlines
// We collect them all, and newlines are allowed anywhere
PromptBlock: PromptBlock<'input> = {
    <items:(PromptItemOrNewline)*> => {
        // Filter out None (newlines) and collect the actual items
        PromptBlock {
            items: items.into_iter().filter_map(|x| x).collect()
        }
    },
};

// Either a prompt item or a newline (which we'll filter out)
PromptItemOrNewline: Option<PromptItem<'input>> = {
    <item:PromptItem> => Some(item),
    newline => None,
};

// Individual prompt item - either text or embedded code
PromptItem: PromptItem<'input> = {
    // Raw prompt text
    <text:prompt_text> => PromptItem::Text(text),

    // Embedded do block within a prompt
    "do" "{" <statements:StatementList> "}" => PromptItem::Code(Block { statements }),
};
