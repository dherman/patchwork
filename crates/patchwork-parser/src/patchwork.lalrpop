// Patchwork grammar - Milestone 2: Top-level items and block structure

use crate::token::ParserToken;
use crate::adapter::ParseError;
use crate::ast::*;

grammar<'input>(input: &'input str);

// External token definition - we use our custom lexer
extern {
    type Location = usize;
    type Error = ParseError;

    enum ParserToken<'input> {
        // Whitespace
        whitespace => ParserToken::Whitespace(<&'input str>),
        newline => ParserToken::Newline(<&'input str>),

        // String literals
        string_start => ParserToken::StringStart,
        string_end => ParserToken::StringEnd,
        string_text => ParserToken::StringText(<&'input str>),
        single_quote_string => ParserToken::SingleQuoteString(<&'input str>),
        dollar => ParserToken::Dollar,

        // Prompt operators
        "think" => ParserToken::Think,
        "ask" => ParserToken::Ask,
        "do" => ParserToken::Do,

        // Keywords
        "import" => ParserToken::Import,
        "from" => ParserToken::From,
        "var" => ParserToken::Var,
        "if" => ParserToken::If,
        "else" => ParserToken::Else,
        "for" => ParserToken::For,
        "while" => ParserToken::While,
        "await" => ParserToken::Await,
        "task" => ParserToken::Task,
        "skill" => ParserToken::Skill,
        "fun" => ParserToken::Fun,
        "type" => ParserToken::Type,
        "return" => ParserToken::Return,
        "succeed" => ParserToken::Succeed,
        "fail" => ParserToken::Fail,
        "break" => ParserToken::Break,
        "self" => ParserToken::SelfKw,
        "in" => ParserToken::In,

        // Literals
        "true" => ParserToken::True,
        "false" => ParserToken::False,
        number => ParserToken::Number(<&'input str>),
        identifier => ParserToken::Identifier(<&'input str>),

        // Multi-character operators
        "..." => ParserToken::Ellipsis,
        "->" => ParserToken::Arrow,
        "==" => ParserToken::Eq,
        "!=" => ParserToken::Neq,
        "<=" => ParserToken::Lte,
        ">=" => ParserToken::Gte,
        "&&" => ParserToken::AndAnd,
        "||" => ParserToken::OrOr,

        // Punctuation
        "{" => ParserToken::LBrace,
        "}" => ParserToken::RBrace,
        "(" => ParserToken::LParen,
        ")" => ParserToken::RParen,
        "[" => ParserToken::LBracket,
        "]" => ParserToken::RBracket,
        ";" => ParserToken::Semicolon,
        "," => ParserToken::Comma,
        ":" => ParserToken::Colon,
        "@" => ParserToken::At,

        // Single-character operators
        "<" => ParserToken::Lt,
        ">" => ParserToken::Gt,
        "+" => ParserToken::Plus,
        "-" => ParserToken::Minus,
        "*" => ParserToken::Star,
        "/" => ParserToken::Slash,
        "%" => ParserToken::Percent,
        "!" => ParserToken::Bang,
        "=" => ParserToken::Assign,
        "|" => ParserToken::Pipe,
        "&" => ParserToken::Ampersand,
        "." => ParserToken::Dot,

        // Prompt text
        prompt_text => ParserToken::PromptText(<&'input str>),

        // Comments
        comment => ParserToken::Comment(<&'input str>),

        // Special
        end => ParserToken::End,
    }
}

// ====================
// Grammar Rules
// ====================

// Program: top-level items
pub Program: Program<'input> = {
    <items:Item*> end => Program { items },
};

// Top-level item
Item: Item<'input> = {
    <ImportDecl> => Item::Import(<>),
    <SkillDecl> => Item::Skill(<>),
    <TaskDecl> => Item::Task(<>),
    <FunctionDecl> => Item::Function(<>),
};

// Import declaration: `import path` or `import ./{a, b, c}`
ImportDecl: ImportDecl<'input> = {
    "import" <path:ImportPath> => ImportDecl { path },
};

// Import path
ImportPath: ImportPath<'input> = {
    // Relative multi-import: ./{analyst, narrator, scribe}
    "." "/" "{" <head:identifier> <tail:("," <identifier>)*> "}" => {
        let mut names = vec![head];
        names.extend(tail);
        ImportPath::RelativeMulti(names)
    },
    // Simple dotted path: For now, just accept identifier sequences
    // Will expand this in later milestones if needed
    <id:identifier> => ImportPath::Simple(vec![id]),
};

// Skill declaration: skill name(params) { body }
SkillDecl: SkillDecl<'input> = {
    "skill" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        SkillDecl { name, params, body }
    },
};

// Task declaration: task name(params) { body }
TaskDecl: TaskDecl<'input> = {
    "task" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        TaskDecl { name, params, body }
    },
};

// Function declaration: fun name(params) { body }
FunctionDecl: FunctionDecl<'input> = {
    "fun" <name:identifier> "(" <params:ParamList> ")" <body:Block> => {
        FunctionDecl { name, params, body }
    },
};

// Parameter list (comma-separated identifiers)
ParamList: Vec<Param<'input>> = {
    // Empty list
    => vec![],
    // Single param
    <head:identifier> => vec![Param { name: head }],
    // Multiple params
    <head:identifier> <tail:("," <identifier>)+> => {
        let mut params = vec![Param { name: head }];
        for name in tail {
            params.push(Param { name });
        }
        params
    },
};

// Block: { statements }
// For Milestone 2, we only recognize empty blocks
// Statement parsing will be added in Milestone 3
Block: Block<'input> = {
    "{" "}" => Block { statements: vec![] },
};
